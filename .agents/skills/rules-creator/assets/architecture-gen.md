# Architecture File Generator (Spec) — 精简强化版（修订｜Modules 版）

## 0) 生成目标（不可变）

* 输出文件：`./docs/global/architecture.md`
* 格式：Markdown
* 语言：中文
* 核心目的：
  **强约束 AI 的代码生成行为，使其严格遵守模块划分、依赖方向与代码落点规则**
* 禁止讨论：

  * 具体框架
  * 具体库
  * 具体实现代码
* 允许讨论：

  * 架构形态
  * 模块职责
  * 依赖边界
  * 文件与目录落点规则

---

## 0.1 前置依赖（强制）

* `docs/global/vision.md`

### 流程（不可跳过）

1. 读取并理解 `vision.md`
2. 若缺失 → **只允许输出以下内容**：

```
缺少依赖 [docs/global/vision.md]
回复「Y」开始创建依赖。
```

3. 若存在 → 继续后续流程

---

## 1) 启动语（固定，不可修改）

> 现在开始创建项目架构（Architecture）。
> 我会一步一步问你问题，你只需要按问题回答即可。
> 在开始前，我会先读取并提炼 vision.md 作为上下文依据。

---

## Q1. 技术栈选择（Primary Framework）

> ⚠️ 本题用于确定本项目的**主框架**，以约束 AI 后续产出一致性。
> 只允许给出 **1–2 个「单一主框架」**备选；**禁止组合方案**（例如「X + Y」）。

### 系统建议（一次性给出）

基于 `vision.md` 判定交付形态后，系统给出 1–2 个主框架备选，并对每个备选用 **2–4 句**说明：

* 适合点（为什么匹配目标 / 迭代速度 / 风险）
* 代价点（会带来什么约束或复杂度）
* 适用边界（本项目哪些范围用它）

输出格式（固定）：

**方案 A：主框架 = <框架名>**

* 优点：…
* 缺点：…
* 适用边界：…

**方案 B：主框架 = <框架名>（可选）**

* 优点：…
* 缺点：…
* 适用边界：…

### 用户选择（只需回答一个字母）

> 请选择主框架：A / B
> 或：C) 我自行指定（写：交付形态 + 框架名）

---

## Q2. 分层与职责（Layered Model）— 建议结构（核心参考）

> ⚠️ 本题用于为本项目建立**推荐的模块类型划分**，
> 作为后续依赖规则与代码落点的基础参考。

### Step 1：系统生成模块建议（必须）

系统需基于以下依据动态生成模块模型：

* Q1 选择的主技术框架
* `vision.md` 描述的产品目标与复杂度
* 当前阶段对可维护性与演进速度的需求

系统将给出一组**推荐的分层类型**，用于说明各层职责边界与协作关系。

**以下为一组示例模块类型（仅作为范例）：**

* Adapter：负责对接并隔离外部系统，作为内部调用的统一入口
* Core：提供与业务无关的基础能力或通用功能
* Service：承载主要业务流程与状态规则
* ComponentLogic：负责组件级逻辑与状态组织，不涉及展示
* ComponentView：负责组件的展示结构与交互呈现
* Component：组合逻辑模块与视图模块，形成可复用的组件单元

> 实际模块名称、数量与职责可根据项目需求进行调整，但应保持职责单一、边界清晰、依赖方向明确。

---

### Step 2：用户确认

> 对这份「分层与职责建议」：
> A) 接受作为当前项目的模块划分参考
> B) 调整（可修改模块名称、职责描述或合并 / 拆分模块）

---

## Q3. 依赖规则（Dependency Rules）— 结构化强制规则

### Step 1：系统生成依赖规则（必须）

系统必须输出**结构化依赖规则**（YAML），并覆盖所有层级：

* 使用字段：`from / allow / forbid / notes`
* `allow/forbid` 只接受分层名称（Adapter/Core/Service/ComponentLogic/ComponentView/Component）
* `allow` 与 `forbid` 必须互斥且穷尽
* 必须覆盖所有层级，保证可被 AI 直接解析

---

### Step 2：用户确认

> 对这份「依赖规则（结构化）」：
> A) 接受
> B) 修改（请直接改文字）

---

## Q4. 目录与落点规则（Project Layout Rules）

> ⚠️ 本题必须结合：
>
> * 当前专案实际目录结构
> * Q1 选定的技术栈方向
> * Q2 模块模型
> * Q3 模块依赖规则

### Step 1：系统生成草案（必须）

系统需提供：

1. **目录与落点清单**（每条目录只负责一种职责）
2. **一句总规则**：所有模块必须落在对应目录，不得跨目录落点

---

### Step 2：用户确认

> 对这份「目录与模块落点规则」：
> A) 接受
> B) 修改（请直接改）

---

## Q5. 禁止事项（Extra Forbids）

> ⚠️ 本题用于补充 **不属于依赖矩阵** 的特殊禁令，
> 例如业务裁决位置、状态机归属、SSOT 写入边界等。

### Step 1：系统生成草案（必须）

系统需提供 **3–6 条**「特殊禁令」，要求：

* 不重复 `layer_rules` 已覆盖的依赖方向限制
* 禁令必须是可判定的行为约束（可被 executor 核对）
* 语气必须为「禁止」或「不得」

### Step 2：用户确认

> 对这份「禁止事项」：
> A) 接受
> B) 修改（请直接改）

---

## 最终输出结构（固定）

```md
# 项目架构（Architecture）

## 架构形态
## 技术栈选择
## 分层与职责
## 依赖规则（结构化定义，供 AI 使用）
```yaml
layer_rules: ...
```
## 目录与落点规则
## 禁止事项
```

---

## 输出后续动作（强制）

在完成 `architecture.md` 生成后：

1. 判断「技术栈选择」是否为**前端技术栈**
2. 若是前端：
   - 必须询问用户是否要继续执行 `ui-architecture-gen.md`
   - 若用户同意：继续进入 UI 规范生成流程
3. 若非前端：直接结束
